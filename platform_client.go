package main

import (
	"context"
	b64 "encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"
)

const (
	Prod = "PROD"
	Test = "TEST"

	BaseURL_prod = "https://api.platform.river.com"
	BaseURL_test = "http://localhost:8080"
)

type PlatformClient struct {
	BaseURL    string
	credential string
	accountId  string
	HTTPClient *http.Client
}

func (pc *PlatformClient) sendRequest(ctx context.Context, req *http.Request, data interface{}) error {
	req = req.WithContext(ctx)
	req.Header.Set("Content-Type", "application/json; charset-utf-8")
	req.Header.Set("Accept", "application/json; charset-utf-8")
	req.Header.Set("Authorization", fmt.Sprintf("basic %s", pc.credential))

	res, err := pc.HTTPClient.Do(req)
	fmt.Print("GET request\n")
	if err != nil {
		select {
		case <-ctx.Done():
			fmt.Print("Context Expired\n")
			return ctx.Err()
		default:
			fmt.Print(err.Error())

			return err
		}
	}
	defer res.Body.Close()
	fmt.Printf("Status Code: %d", res.StatusCode)
	if res.StatusCode < http.StatusOK || res.StatusCode >= http.StatusBadRequest {
		var errRes errorResponse
		err = json.NewDecoder(res.Body).Decode(&errRes)
		if err == nil {
			return errors.New(errRes.Message)
		}

		return fmt.Errorf("error: %d", res.StatusCode)
	}

	fullResponse := successResponse{
		Data: data,
	}
	err = json.NewDecoder(res.Body).Decode(&fullResponse)
	if err != nil {
		return err
	}
	return nil
}

// Ping does ping pong with the API server at /
func (pc *PlatformClient) Ping(ctx context.Context) error {
	req, err := http.NewRequest("GET", fmt.Sprintf("%s/", pc.BaseURL), nil)
	if err != nil {
		return err
	}

	var res interface{}
	err = pc.sendRequest(ctx, req, &res)
	if err != nil {
		return err
	}
	return nil
}

// // InitiateWithdrawal initiates a withdrawal from River Platform API by paying a specific invoice
// func (pc *PlatformClient) InitiateWithdrawal(amount int, invoice, currency, network string, fee_limit int) {

// }

// // GetWithdrawal returns a withdrawal based on the passed withdrawal_id
// func (pc *PlatformClient) GetWithdrawal(withdrawal_id string) {

// }

// // CreateDepositInvoice creates an invoice to enable deposits to River Platform
// func (pc *PlatformClient) CreateDepositInvoice(amount int, label, network string) {

// }

// // GetDepositInvoices queries a list of invoices generated by River Platform
// func (pc *PlatformClient) GetDepositInvoices(limit, next_timestamp int) {

// }

// // GetDeposits returns a list of deposits (settled invoices) to River Platform
// func (pc *PlatformClient) GetDeposits(limit, next_timestamp int) {

// }

// // SubscribeToWebhook subscribes to a webhook
// func (pc *PlatformClient) SubscribeToWebhook(callback_url string) {

// }

// // GetSubscribedWebhook queries subscribed webhook
// func (pc *PlatformClient) GetSubscribedWebhook() {

// }

// // DeleteWebhook deletes the existing webhook
// func (pc *PlatformClient) DeleteWebhook() {

// }

// // DecodeInvoice decodes a Lightning Invoice using River Platform using `lncli decodepayreq`
// func (pc *PlatformClient) DecodeInvoice(invoice string) {

// }

// // EstimateLightningFee estimates Lightning Fee of an invoice using `lncli`
// func (pc *PlatformClient) EstimateLightningFee(invoice string, amount int) {

// }

func createCredential(apiKey string) string {
	key := fmt.Sprintf("%s:%s", apiKey, apiKey)
	return b64.StdEncoding.EncodeToString([]byte(key))
}

func NewPlatformClient(apiKey string, accountId, env string) *PlatformClient {
	BaseURL := BaseURL_prod
	if env != Prod {
		BaseURL = BaseURL_test
	}
	return &PlatformClient{
		BaseURL:    BaseURL,
		accountId:  accountId,
		credential: createCredential(apiKey),
		HTTPClient: &http.Client{
			Timeout: time.Minute,
		},
	}
}

func main() {
	ctx := context.Background()
	pc := NewPlatformClient("Au4FlGJ4DnnA6L12p4ZJEBOdikEKSqhkivOhc3pPlRs=", "acc_2CTR45VR", "PROD")
	pc.Ping(ctx)
}
